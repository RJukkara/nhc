# Tests for common.nhc

plan $((22+11+11+13+11+28+9+7+15+6+7+4+6+18+7+19+2+8)) "common.nhc" && {
    is "`type -t array_push 2>&1`" 'function' 'array_push() loaded properly'
    is "`type -t array_pop 2>&1`" 'function' 'array_pop() loaded properly'
    is "`type -t array_unshift 2>&1`" 'function' 'array_unshift() loaded properly'
    is "`type -t array_shift 2>&1`" 'function' 'array_shift() loaded properly'
    is "`type -t array_split 2>&1`" 'function' 'array_split() loaded properly'
    is "`type -t array_join 2>&1`" 'function' 'array_join() loaded properly'
    is "`type -t str_clean 2>&1`" 'function' 'str_clean() loaded properly'
    is "`type -t mcheck_regexp 2>&1`" 'function' 'mcheck_regexp() loaded properly'
    is "`type -t mcheck_range 2>&1`" 'function' 'mcheck_range() loaded properly'
    is "`type -t mcheck_external 2>&1`" 'function' 'mcheck_external() loaded properly'
    is "`type -t mcheck_glob 2>&1`" 'function' 'mcheck_glob() loaded properly'
    is "`type -t mcheck 2>&1`" 'function' 'mcheck() loaded properly'
    is "`type -t nhc_load_conf 2>&1`" 'function' 'nhc_load_conf() loaded properly'
    is "`type -t nhc_common_load_passwd 2>&1`" 'function' 'nhc_common_load_passwd() loaded properly'
    is "`type -t nhc_common_get_uid 2>&1`" 'function' 'nhc_common_get_uid() loaded properly'
    is "`type -t nhc_common_parse_size 2>&1`" 'function' 'nhc_common_parse_size() loaded properly'
    is "`type -t nhc_common_unparse_size 2>&1`" 'function' 'nhc_common_unparse_size() loaded properly'
    is "`type -t nhc_common_parse_count 2>&1`" 'function' 'nhc_common_parse_count() loaded properly'
    is "`type -t nhc_common_unparse_count 2>&1`" 'function' 'nhc_common_unparse_count() loaded properly'
    is "`type -t nhc_common_get_unix_time 2>&1`" 'function' 'nhc_common_get_unix_time() loaded properly'
    is "`type -t nhc_cmd_with_timeout 2>&1`" 'function' 'nhc_cmd_with_timeout() loaded properly'
    is "`type -t nhc_common_get_max_sys_uid 2>&1`" 'function' 'nhc_common_get_max_sys_uid() loaded properly'

    typeset -a TA=( ) A1=( ) A2=( ) A3=( )
    array_push 'TA' '0100' '0010' '0000' '0001' '1000' '0110'
    is $? 0 "array_push() succeeds"
    is ${#TA[*]} 6 "Test array \$TA contains 6 elements"
    is "${TA[0]}" '0100' "Spot-checking contents of test array, element 0"
    is "${TA[2]}" '0000' "Spot-checking contents of test array, element 2"
    is "${TA[5]}" '0110' "Spot-checking contents of test array, element 5"
    array_push 'TA' '0111' '1111'
    is $? 0 "array_push() succeeds"
    is ${#TA[*]} 8 "Test array \$TA now contains 8 elements"
    is "${TA[2]}" '0000' "Spot-checking contents of test array, element 2"
    is "${TA[4]}" '1000' "Spot-checking contents of test array, element 4"
    is "${TA[6]}" '0111' "Spot-checking contents of test array, element 6"
    is "${TA[7]}" '1111' "Spot-checking contents of test array, element 7"

    array_pop 'TA'
    is $? 0 "array_pop() succeeds"
    is ${#TA[*]} 7 "Test array \$TA now contains 7 elements after popping 1"
    is "${TA[0]}" '0100' "First element of \$TA should remain unchanged"
    is "${TA[6]}" '0111' "Last element of \$TA should now be element 6 (above)"
    is ${#A1[*]} 0 "Result array \$A1 should still be empty"
    array_pop 'TA' 3 A1
    is ${#TA[*]} 4 "Test array \$TA now contains 4 elements after popping 3"
    is "${TA[0]}" '0100' "First element of \$TA should remain unchanged"
    is "${TA[3]}" '0001' "Last element of \$TA should now be element 3"
    is ${#A1[*]} 3 "Result array \$A1 should now have the 3 popped elements"
    is "${A1[0]}" '1000' "First element of \$A1 should now be former \$TA[4]"
    is "${A1[2]}" '0111' "Last element of \$A1 should now be the former \$TA[6]"

    TA=( a b c d e f g )
    array_shift 'TA'
    is $? 0 "array_shift() with no count should default to 1 and succeed"
    #(IFS='|' printf '\n\n%s\n\n' "${TA[*]}")
    is "${TA[0]}" 'b' "First element of \$TA is the former 2nd element"
    is "${#TA[*]}" 6 "Test array \$TA now contains 6 elements after shifting 1"
    array_shift 'TA' 3
    is $? 0 "array_shift() succeeds"
    is "${TA[0]}" 'e' "First element of \$TA is now 'e'"
    is "${#TA[*]}" 3 "Test array \$TA now contains 3 elements after shifting 3"
    array_shift 'TA' 12
    is $? 0 "array_shift() succeeds even if the count is too large"
    is "${#TA[*]}" 0 "Test array \$TA is now empty"
    TA=( a b c d e f g )
    array_shift 'TA' -3 'A2'
    is $? 0 "array_shift() succeeds even if the count is negative (flips sign)"
    is "${TA[0]}" 'd' "Test array \$TA should now be ( d e f g ) and not ( a b c d )"
    is "${#TA[*]}" 4 "Test array \$TA should now contain 3 fewer elements"
    is "${A2[0]}" 'a' "Test array \$A2 should now contain the 3 shifted values"
    is "${#A2[*]}" 3 "Test array \$A2 should now have 3 entries"

    TA=( g h i j ) A3=( a b c d )
    array_unshift 'TA' e f
    is $? 0 "array_shift() succeeds"
    is "${#TA[*]}" 6 "Test array \$TA now contains 6 elements after unshifting 2"
    is "${TA[0]}" 'e' "First element of \$TA is now 'e'"
    is "${TA[2]}" 'g' "Third element of \$TA is now 'g'"
    is "${TA[5]}" 'j' "Last element of \$TA is now 'j'"
    array_unshift 'TA' "${A3[@]}"
    is $? 0 "array_unshift() succeeds"
    is "${#TA[*]}" 10 "Test array \$TA now contains 10 elements after unshifting ${#A3[*]}"
    is "${TA[0]}" 'a' "First element of \$TA is now 'a'"
    is "${TA[3]}" 'd' "Fourth element of \$TA is now 'd'"
    is "${TA[6]}" 'g' "Seventh element of \$TA is now 'g'"
    is "${TA[9]}" 'j' "Last element of \$TA is now 'j'"

    TA=(  ) TS="0:1:2:3:4:5:" S1="" S2="" S3=""
    array_split ':' "$TS" 'TA'
    is $? 0 "array_split() succeeds on colon-delimited string"
    is "${#TA[*]}" 6 "Test array \$TA should now contain 6 elements"
    is "${TA[0]}" '0' "First element of \$TA is now '0'"
    is "${TA[2]}" '2' "Third element of \$TA is now '2'"
    is "${TA[4]}" '4' "Fifth element of \$TA is now '4'"
    printf -v S1 '%s\n%s\n%s\n' " a b c d " "e f g h" "i j   k l"
    array_split $'\n' "$S1" 'TA'
    is $? 0 "array_split() succeeds on a string with newlines"
    is "${#TA[*]}" 3 "Test array \$TA should be repopulated with 3 new strings"
    is "${TA[0]}" ' a b c d ' "First string after splitting on newlines"
    is "${TA[1]}" 'e f g h' "Second string after splitting on newlines"
    is "${TA[2]}" 'i j   k l' "Third string after splitting on newlines"
    S1="${TA[0]}" S2="${TA[1]}" S3="${TA[2]}"
    array_split ' ' "$S1" 'TA'
    is $? 0 "array_split() succeeds on the previous 1st line string"
    is "${#TA[*]}" 4 "Test array \$TA should now comprise the 4 single-letter strings of the 1st line"
    is "${TA[0]}" 'a' "First 1-letter string after splitting \"$S1\" on spaces"
    is "${TA[1]}" 'b' "Second 1-letter string after splitting \"$S1\" on spaces"
    is "${TA[2]}" 'c' "Third 1-letter string after splitting \"$S1\" on spaces"
    is "${TA[3]}" 'd' "Fourth 1-letter string after splitting \"$S1\" on spaces"
    array_split ' ' "$S2" 'TA'
    is $? 0 "array_split() succeeds on the previous 2nd line string"
    is "${#TA[*]}" 4 "Test array \$TA should now comprise the 4 single-letter strings of the 2nd line"
    is "${TA[0]}" 'e' "First 1-letter string after splitting \"$S2\" on spaces"
    is "${TA[1]}" 'f' "Second 1-letter string after splitting \"$S2\" on spaces"
    is "${TA[2]}" 'g' "Third 1-letter string after splitting \"$S2\" on spaces"
    is "${TA[3]}" 'h' "Fourth 1-letter string after splitting \"$S2\" on spaces"
    array_split ' ' "$S3" 'TA'
    is $? 0 "array_split() succeeds on the previous 3rd line string"
    is "${#TA[*]}" 4 "Test array \$TA should now comprise the 4 single-letter strings of the 3rd line"
    is "${TA[0]}" 'i' "First 1-letter string after splitting \"$S3\" on spaces"
    is "${TA[1]}" 'j' "Second 1-letter string after splitting \"$S3\" on spaces"
    is "${TA[2]}" 'k' "Third 1-letter string after splitting \"$S3\" on spaces"
    is "${TA[3]}" 'l' "Fourth 1-letter string after splitting \"$S3\" on spaces"

    TA=( {0..5} ) S1="" S2="" S3=""
    array_join ',' 'TA' 'S1'
    is $? 0 "array_join() succeeds on a small, simple numeric array"
    is "${#S1}" 11 "Joining elements of test array \$TA with commas should make an 11-byte string (6 numbers, 5 commas)"
    is "$S1" "0,1,2,3,4,5" "Resulting string value for comma-delimited joined array"
    TA+=( 6 7 )
    array_join '' 'TA' 'S2'
    is $? 0 "array_join() succeeds with an empty delimiter string"
    is "${#S2}" 8 "Joining elements of test array \$TA (0-7) with no delimiter should make an 8-byte string"
    is "$S2" "01234567" "Resulting string value for concatenated array"
    array_join ' || ' 'TA' 'S3'
    is $? 0 "array_join() succeeds with a spaces-and-double-pipe delimiter"
    is "${#S3}" 36 "Joining \$TA's 8 elements with ' || ' should make a 36-byte string (8 numbers, 7 4-char delimiters)"
    is "$S3" '0 || 1 || 2 || 3 || 4 || 5 || 6 || 7' "Resulting string value for comma-delimited joined array"

    mcheck "This is a test." '/test/'
    is $? 0 "Basic regexp match via mcheck()"
    mcheck "some.hostname.com" '/\./'
    is $? 0 "Metacharacter escape regexp match via mcheck()"
    mcheck "hostname" '/\./'
    is $? 1 "Failed regexp match via mcheck()"
    mcheck "host.example.com" '/example\.(com|net|org)$/'
    is $? 0 "Extended regexp match via mcheck()"
    mcheck "1 2 3 4 5" '/(^| )1/'
    is $? 0 "Boundary case regexp match via mcheck()"
    mcheck "somenode" '!/node/'
    is $? 1 "Negated regexp match via mcheck(), matching node"
    mcheck "bigmem01" '!/gpu/'
    is $? 0 "Negated regexp match via mcheck(), non-matching node"

    mcheck "n0000.testbed" '{n00[00-59].testbed}'
    is $? 0 "Basic range match via mcheck(), lower bound"
    mcheck "n0021.testbed" '{n00[00-59].testbed}'
    is $? 0 "Basic range match via mcheck(), mid-range"
    mcheck "n0059.testbed" '{n00[00-59].testbed}'
    is $? 0 "Basic range match via mcheck(), upper bound"
    mcheck "n0000.testbed" '{n0[000-059].testbed}'
    is $? 0 "Basic range match via mcheck() with leading zeroes, lower bound"
    mcheck "n0034.testbed" '{n0[000-059].testbed}'
    is $? 0 "Basic range match via mcheck() with leading zeroes, mid-range"
    mcheck "n0059.testbed" '{n0[000-059].testbed}'
    is $? 0 "Basic range match via mcheck() with leading zeroes, upper bound"
    mcheck "n0000.cluster" '{n0000.cluster}'
    is $? 0 "Range check via mcheck(), simple exact name match"
    mcheck "n0100.cluster" '{n00[00-99].cluster}'
    is $? 1 "Failed range match via mcheck()"
    mcheck "n0005.cluster" '{n000[5-5].cluster}'
    is $? 0 "Range check via mcheck(), range containing only 1 node"
    mcheck "n0200.cluster" '{n[00-10]00.cluster}'
    is $? 0 "Range check via mcheck(), range in non-standard location"
    mcheck "fx-r0-n42" '{fx-r0-n[0-42]}'
    is $? 0 "Range check via mcheck(), range with unbalanced lengths"
    mcheck "idplx-r2-n21" '{idplx-r0-n[0-42],idplx-r1-n[0-42],idplx-r2-n[0-42],idplx-r3-n[0-42]}'
    is $? 0 "Range check via mcheck(), multiple comma-delimited ranges"
    mcheck "idplx-r4-n04" '{idplx-r0-n[0-42],idplx-r1-n[0-42],idplx-r2-n[0-42],idplx-r3-n[0-42]}'
    is $? 1 "Failed range check via mcheck(), multiple comma-delimited ranges"
    mcheck "n2345.gpu" '!{n[0000-9999].gpu}'
    is $? 1 "Negated range check, matching node"
    mcheck "n1123.phi" '!{n0[100-199].phi}'
    is $? 0 "Negated range check, non-matching node"

    NHC_MCHECK_DELIM[0]='%'
    NHC_MCHECK_COMMAND[0]='true'
    mcheck "Anything can go here" '%Anything at all%'
    is $? 0 "Simple external match check test with /bin/true"
    NHC_MCHECK_COMMAND[0]='false'
    mcheck "Anything can go here" '%Anything at all%'
    is $? 1 "Simple external match check test with /bin/false"
    NHC_MCHECK_COMMAND='echo -e "host1\nhost2\nhost3" | fgrep -xqm1 %h'
    mcheck "host2" '%doesnotmatter%'
    is $? 0 "External match check with echo and fgrep, positive match"
    mcheck "host4" '%doesnotmatter%'
    is $? 1 "External match check with echo and fgrep, negative match"
    mcheck "host1" '!%doesnotmatter%'
    is $? 1 "Negated external match check with echo and fgrep, matching string"
    mcheck "randomcrap" '!%doesnotmatter%'
    is $? 0 "Negated external match check with echo and fgrep, non-matching string"

    mcheck "n0000.testbed" 'n*.*'
    is $? 0 "Basic glob match via mcheck()"
    mcheck "some*glob" '*\**'
    is $? 0 "Metacharacter escape glob match via mcheck()"
    mcheck "hostname" '\*'
    is $? 1 "Failed glob match via mcheck()"
    mcheck "host.example.com" '*.?xample.[CcNnOo][OoEeRr][MmTtGg]'
    is $? 0 "Bracket glob match via mcheck()"
    mcheck "1 2 3 4 5" '*1*'
    is $? 0 "Boundary case glob match via mcheck()"
    mcheck "n0001" '!n00*'
    is $? 1 "Negated glob match via mcheck(), matching node"
    mcheck "n0001" '!n11*'
    is $? 0 "Negated glob match via mcheck(), non-matching node"

    mcheck_regexp 'Testing' '/^Testing$/'
    is $? 1 "Direct usage of mcheck_regexp() with slashes (wrong)"
    mcheck_regexp 'Testing' '^Testing$'
    is $? 0 "Direct usage of mcheck_regexp() without slashes (correct)"
    mcheck_range 'n0000.foo' '{n000[0-9].foo}'
    is $? 1 "Direct usage of mcheck_range() with braces (wrong)"
    mcheck_range 'n0000.foo' 'n000[0-9].foo'
    is $? 0 "Direct usage of mcheck_range() without braces (correct)"

    OSIZE="1023kB"
    nhc_common_parse_size $OSIZE NSIZE
    is $NSIZE 1023 "nhc_common_parse_size():  1023kB -> 1023"
    OSIZE="1023MB"
    nhc_common_parse_size $OSIZE NSIZE
    is $NSIZE $((1023*1024)) "nhc_common_parse_size():  1023MB -> $((1023*1024))"
    OSIZE="100GB"
    nhc_common_parse_size $OSIZE NSIZE
    is $NSIZE $((100*1024*1024)) "nhc_common_parse_size():  100GB -> $((100*1024*1024))"
    OSIZE="6Tb"
    nhc_common_parse_size $OSIZE NSIZE
    is $NSIZE $((6*1024*1024*1024)) "nhc_common_parse_size():  6Tb -> $((6*1024*1024*1024))"
    OSIZE="1pb"
    nhc_common_parse_size $OSIZE NSIZE
    is $NSIZE $((1024*1024*1024*1024)) "nhc_common_parse_size():  1pb -> $((1024*1024*1024*1024))"
    OSIZE="1eb"
    nhc_common_parse_size $OSIZE NSIZE
    is $NSIZE $((1024*1024*1024*1024*1024)) "nhc_common_parse_size():  1eb -> $((1024*1024*1024*1024*1024))"

    OSIZE=$((1024*1024*1024*1024*1024*1024))
    nhc_common_unparse_size $OSIZE NSIZE
    is "$NSIZE" "1024EB" "nhc_common_unparse_size():  $OSIZE -> 1024EB"
    OSIZE=$((1024*1024*1024*1024*1024))
    nhc_common_unparse_size $OSIZE NSIZE
    is "$NSIZE" "1EB" "nhc_common_unparse_size():  $OSIZE -> 1EB"
    OSIZE=$((1023*1024*1024*1024*1024))
    nhc_common_unparse_size $OSIZE NSIZE
    is "$NSIZE" "1023PB" "nhc_common_unparse_size():  $OSIZE -> 1023PB"
    OSIZE=$((64*1024*1024*1024))
    nhc_common_unparse_size $OSIZE NSIZE
    is "$NSIZE" "64TB" "nhc_common_unparse_size():  $OSIZE -> 64TB"
    OSIZE=$((4*1024*1024))
    nhc_common_unparse_size $OSIZE NSIZE
    is "$NSIZE" "4GB" "nhc_common_unparse_size():  $OSIZE -> 4GB"
    OSIZE=$((1023*1024))
    nhc_common_unparse_size $OSIZE NSIZE
    is "$NSIZE" "1023MB" "nhc_common_unparse_size():  $OSIZE -> 1023MB"
    OSIZE=$((1024))
    nhc_common_unparse_size $OSIZE NSIZE
    is "$NSIZE" "1MB" "nhc_common_unparse_size():  $OSIZE -> 1MB"
    OSIZE=$((1000))
    nhc_common_unparse_size $OSIZE NSIZE
    is "$NSIZE" "1000kB" "nhc_common_unparse_size():  $OSIZE -> 1000kB"
    OSIZE=$(((5*1024/100+1024)*1024))
    nhc_common_unparse_size $OSIZE NSIZE 1024 ERR
    is "$NSIZE" "1GB" "nhc_common_unparse_size():  $OSIZE -> 1GB with 51MB error (size)"
    is "$ERR" "51" "nhc_common_unparse_size():  $OSIZE -> 1GB with 51MB error (error)"
    OSIZE=$(((15*1024/100+1024)*1024*1024))
    nhc_common_unparse_size $OSIZE NSIZE 1024 ERR
    is "$NSIZE" "1177GB" "nhc_common_unparse_size():  $OSIZE -> 1177GB (1.15TB) with 0GB error (size)"
    is "$ERR" "0" "nhc_common_unparse_size():  $OSIZE -> 1177GB (1.15TB) with 0GB error (error)"
    OSIZE=$(((50*1024/100+1024)*1024*1024))
    nhc_common_unparse_size $OSIZE NSIZE 1024 ERR
    is "$NSIZE" "1536GB" "nhc_common_unparse_size():  $OSIZE -> 1536GB (1.5TB) with 0GB error (size)"
    is "$ERR" "0" "nhc_common_unparse_size():  $OSIZE -> 1536GB (1.5TB) with 0GB error (error)"
    OSIZE=$((75*1024/100+1024))
    nhc_common_unparse_size $OSIZE NSIZE 1024 ERR
    is "$NSIZE" "1792kB" "nhc_common_unparse_size():  $OSIZE -> 1792kB (1.75MB) with 0kB error (size)"
    is "$ERR" "0" "nhc_common_unparse_size():  $OSIZE -> 1792kB (1.75MB) with 0kB error (error)"
    OSIZE=$(((99*1024/100+1024)*1024*1024*1024))
    nhc_common_unparse_size $OSIZE NSIZE 1024 ERR
    is "$NSIZE" "2PB" "nhc_common_unparse_size():  $OSIZE -> 2PB (1.99PB) with 11TB error (size)"
    is "$ERR" "11" "nhc_common_unparse_size():  $OSIZE -> 2PB (1.99PB) with 11TB error (error)"

    OSIZE="999"
    nhc_common_parse_count $OSIZE NSIZE
    is $NSIZE 999 "nhc_common_parse_count():  999 -> 999"
    OSIZE="999k"
    nhc_common_parse_count $OSIZE NSIZE
    is $NSIZE $((999*1000)) "nhc_common_parse_count():  999k -> 999000"
    OSIZE="999M"
    nhc_common_parse_count $OSIZE NSIZE
    is $NSIZE $((999*1000*1000)) "nhc_common_parse_count():  999M -> $((999*1000*1000))"
    OSIZE="100G"
    nhc_common_parse_count $OSIZE NSIZE
    is $NSIZE $((100*1000*1000*1000)) "nhc_common_parse_count():  100G -> $((100*1000*1000*1000))"
    OSIZE="6T"
    nhc_common_parse_count $OSIZE NSIZE
    is $NSIZE $((6*1000*1000*1000*1000)) "nhc_common_parse_count():  6T -> $((6*1000*1000*1000*1000))"
    OSIZE="1p"
    nhc_common_parse_count $OSIZE NSIZE
    is $NSIZE $((1000*1000*1000*1000*1000)) "nhc_common_parse_count():  1p -> $((1000*1000*1000*1000*1000))"
    OSIZE="1e"
    nhc_common_parse_count $OSIZE NSIZE
    is $NSIZE $((1000*1000*1000*1000*1000*1000)) "nhc_common_parse_count():  1e -> $((1000*1000*1000*1000*1000*1000))"

    OSIZE=$((1000*1000*1000*1000*1000*1000))
    nhc_common_unparse_count $OSIZE NSIZE
    is "$NSIZE" "1E" "nhc_common_unparse_count():  $OSIZE -> 1E"
    OSIZE=$((999*1000*1000*1000*1000*1000))
    nhc_common_unparse_count $OSIZE NSIZE
    is "$NSIZE" "999P" "nhc_common_unparse_count():  $OSIZE -> 999P"
    OSIZE=$((64*1000*1000*1000*1000))
    nhc_common_unparse_count $OSIZE NSIZE
    is "$NSIZE" "64T" "nhc_common_unparse_count():  $OSIZE -> 64T"
    OSIZE=$((4*1000*1000*1000))
    nhc_common_unparse_count $OSIZE NSIZE
    is "$NSIZE" "4G" "nhc_common_unparse_count():  $OSIZE -> 4G"
    OSIZE=$((999*1000*1000))
    nhc_common_unparse_count $OSIZE NSIZE
    is "$NSIZE" "999M" "nhc_common_unparse_count():  $OSIZE -> 999M"
    OSIZE=$((1000*1000))
    nhc_common_unparse_count $OSIZE NSIZE
    is "$NSIZE" "1M" "nhc_common_unparse_count():  $OSIZE -> 1M"
    OSIZE=$((999*1000))
    nhc_common_unparse_count $OSIZE NSIZE
    is "$NSIZE" "999k" "nhc_common_unparse_count():  $OSIZE -> 999k"
    OSIZE=1000
    nhc_common_unparse_count $OSIZE NSIZE
    is "$NSIZE" "1k" "nhc_common_unparse_count():  $OSIZE -> 1k"
    OSIZE=999
    nhc_common_unparse_count $OSIZE NSIZE
    is "$NSIZE" 999 "nhc_common_unparse_count():  $OSIZE -> 999"
    OSIZE=$(((10*1000/100+1000)*1000))
    nhc_common_unparse_count $OSIZE NSIZE 1000 ERR
    is "$NSIZE" "1M" "nhc_common_unparse_count():  $OSIZE -> 1M with 100k error (size)"
    is "$ERR" "100" "nhc_common_unparse_count():  $OSIZE -> 1M with 100k error (error)"
    OSIZE=$(((10*1000/100+1010)*1000))
    nhc_common_unparse_count $OSIZE NSIZE 1000 ERR
    is "$NSIZE" "1110k" "nhc_common_unparse_count():  $OSIZE -> 1110k with 0 error (size)"
    is "$ERR" "0" "nhc_common_unparse_count():  $OSIZE -> 1110k with 0 error (error)"
    OSIZE=$(((50*1000/100+1000)*1000*1000))
    nhc_common_unparse_count $OSIZE NSIZE 1000 ERR
    is "$NSIZE" "1500M" "nhc_common_unparse_count():  $OSIZE -> 1500M (1.5G) with 0 error (size)"
    is "$ERR" "0" "nhc_common_unparse_count():  $OSIZE -> 1500M (1.5G) with 0 error (error)"
    OSIZE=$((90*1000/100+990))
    nhc_common_unparse_count $OSIZE NSIZE 1000 ERR
    is "$NSIZE" "1890" "nhc_common_unparse_count():  $OSIZE -> 1890 with 0 error (size)"
    is "$ERR" "0" "nhc_common_unparse_count():  $OSIZE -> 1890 with 0 error (error)"
    OSIZE=$(((90*1000/100+1000)*1000*1000*1000))
    nhc_common_unparse_count $OSIZE NSIZE 1000 ERR
    is "$NSIZE" "2T" "nhc_common_unparse_count():  $OSIZE -> 2T (1.90G) with 100G error (size)"
    is "$ERR" "100" "nhc_common_unparse_count():  $OSIZE -> 2T (1.90G) with 100G error (error)"

    # Quick-and-simple sanity check for the timekeeping transform
    UNIXTIME=$(date '+%s')
    OLDSECS=$SECONDS
    cmp_ok "$SECONDS" "-lt" "60" 'Initial $SECONDS value should be small (sub-1min)'
    nhc_common_get_unix_time
    ok '(( (SECONDS <= UNIXTIME+OLDSECS+5) && (SECONDS >= UNIXTIME+OLDSECS-5) ))' \
        "\$SECONDS ($SECONDS) should now reflect \`time_t\` value (roughly $UNIXTIME+$OLDSECS +/- 5s)"

    if [[ $- == *x* ]]; then
        # There seems to be a bash bug.  It doesn't handle process substitution
        # correctly (i.e., <(...) constructs) when debugging (set -x).  Skip.
        skip 8
        export MAX_SYS_UID=499
    else
        LOGIN_DEFS_SRC=<(echo -e "SYS_UID_MAX\t\t\t  199") nhc_common_get_max_sys_uid
        is "$MAX_SYS_UID" 199 "nhc_common_get_max_sys_uid():  \$MAX_SYS_UID <- 199"
        LOGIN_DEFS_SRC=<(echo -e "UID_MIN\t\t\t  500") nhc_common_get_max_sys_uid
        is "$MAX_SYS_UID" 499 "nhc_common_get_max_sys_uid():  \$MAX_SYS_UID <- 499"
        LOGIN_DEFS_SRC=<(echo -e "UID_MIN       1000") nhc_common_get_max_sys_uid
        is "$MAX_SYS_UID" 999 "nhc_common_get_max_sys_uid():  \$MAX_SYS_UID <- 999"
        LOGIN_DEFS_SRC=<(echo -e "UID_MIN\t0\t") nhc_common_get_max_sys_uid
        is "$MAX_SYS_UID" 99 "nhc_common_get_max_sys_uid():  \$MAX_SYS_UID <- 0"
        LOGIN_DEFS_SRC=<(echo -e "GID_MIN\t\t\t  1234") nhc_common_get_max_sys_uid
        is "$MAX_SYS_UID" 99 "nhc_common_get_max_sys_uid():  Bad syntax"
        LOGIN_DEFS_SRC=<(echo -e "2345") nhc_common_get_max_sys_uid
        is "$MAX_SYS_UID" 99 "nhc_common_get_max_sys_uid():  Ignore plain number"
        LOGIN_DEFS_SRC=<(echo -e "stuff\nGID_MIN 1\nGID_MAX 4\nUID_MIN 3\nUID_MAX 7\nblah blah blah\n") nhc_common_get_max_sys_uid
        is "$MAX_SYS_UID" 2 "nhc_common_get_max_sys_uid():  Multiline input"
        unset MAX_SYS_UID
        LOGIN_DEFS_SRC="" nhc_common_get_max_sys_uid
        is "$MAX_SYS_UID" 99 "nhc_common_get_max_sys_uid():  Reset default"
    fi

} ; unplan
